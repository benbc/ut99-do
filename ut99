#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

die() {
    echo "error: $*" >&2
    exit 1
}

info() {
    echo "==> $*"
}

[[ -f "$SCRIPT_DIR/ut99.conf" ]] || die "Config file not found: $SCRIPT_DIR/ut99.conf (see ut99.conf.example)"
source "$SCRIPT_DIR/ut99.conf"
[[ -n "${DROPLET_NAME:-}" ]] || die "DROPLET_NAME not set in ut99.conf"
[[ -n "${REGION:-}" ]]       || die "REGION not set in ut99.conf"
[[ -n "${SPACE_NAME:-}" ]]   || die "SPACE_NAME not set in ut99.conf"
[[ ${#MAP_ROTATION[@]} -gt 0 ]] 2>/dev/null || die "MAP_ROTATION not set in ut99.conf"

DROPLET_SIZE="s-1vcpu-1gb"
DROPLET_IMAGE="ubuntu-24-04-x64"

check_deps() {
    command -v doctl >/dev/null 2>&1 || die "doctl not found. Install from https://docs.digitalocean.com/reference/doctl/"
    command -v ssh >/dev/null 2>&1 || die "ssh not found"
    command -v nc >/dev/null 2>&1 || die "nc (netcat) not found"
    doctl account get >/dev/null 2>&1 || die "doctl not authenticated. Run: doctl auth init"
}

find_droplet() {
    doctl compute droplet list --format ID,Name --no-header \
        | awk -v name="$DROPLET_NAME" '$2 == name { print $1; exit }'
}

get_droplet_ip() {
    local droplet_id="$1"
    doctl compute droplet get "$droplet_id" --format PublicIPv4 --no-header
}

get_droplet_status() {
    local droplet_id="$1"
    doctl compute droplet get "$droplet_id" --format Status --no-header
}

require_running_droplet() {
    DROPLET_ID=$(find_droplet)
    [[ -n "$DROPLET_ID" ]] || die "No droplet '$DROPLET_NAME' found. Run: ut99 create"

    local status
    status=$(get_droplet_status "$DROPLET_ID")
    [[ "$status" == "active" ]] || die "Droplet '$DROPLET_NAME' is not running (status: $status)"

    DROPLET_IP=$(get_droplet_ip "$DROPLET_ID")
}

wait_for_active() {
    local droplet_id="$1"
    info "Waiting for droplet to become active..."
    local status
    for i in $(seq 1 60); do
        status=$(get_droplet_status "$droplet_id")
        [[ "$status" == "active" ]] && return 0
        sleep 5
    done
    die "Timed out waiting for droplet to become active (status: $status)"
}

wait_for_ssh() {
    local ip="$1"
    info "Waiting for SSH to become available..."
    for i in $(seq 1 60); do
        if ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=accept-new \
               "root@${ip}" true 2>/dev/null; then
            return 0
        fi
        sleep 5
    done
    die "Timed out waiting for SSH on $ip"
}

wait_for_off() {
    local droplet_id="$1"
    info "Waiting for droplet to power off..."
    local status
    for i in $(seq 1 60); do
        status=$(get_droplet_status "$droplet_id")
        [[ "$status" == "off" ]] && return 0
        sleep 5
    done
    die "Timed out waiting for droplet to power off (status: $status)"
}

check_server_health() {
    local ip="$1"
    info "Checking UT99 server is responding..."
    for i in $(seq 1 30); do
        if echo -ne '\\status\\' | nc -u -w 2 "$ip" 7778 2>/dev/null | grep -q '\\gamename\\ut\\'; then
            return 0
        fi
        sleep 2
    done
    die "UT99 server on $ip:7778 is not responding"
}

usage() {
    cat <<'USAGE'
Usage: ut99 <command>

Commands:
  create   Create and provision a UT99 server
  destroy  Destroy the UT99 server
  start    Start the UT99 server (power on)
  stop     Stop the UT99 server (power off)
  maps     List available maps, or set map rotation
USAGE
}

provision_server() {
    local ip="$1"
    local space_url="https://${SPACE_NAME}.${REGION}.digitaloceanspaces.com"

    info "Provisioning UT99 server on $ip..."

    ssh -o StrictHostKeyChecking=accept-new "root@${ip}" bash -s -- "$space_url" <<'PROVISION'
set -euo pipefail

export DEBIAN_FRONTEND=noninteractive

echo "==> Waiting for apt lock (unattended-upgrades may be running)..."
apt-get -o DPkg::Lock::Timeout=120 update -qq
apt-get -o DPkg::Lock::Timeout=120 install -y -qq libstdc++6 ufw p7zip-full jq lbzip2 > /dev/null

echo "==> Downloading UT99 installer..."
cd /tmp
curl -fsSL -o install-ut99.sh \
    "https://raw.githubusercontent.com/OldUnreal/FullGameInstallers/master/Linux/install-ut99.sh"
chmod +x install-ut99.sh

echo "==> Installing UT99..."
echo "yes" | ./install-ut99.sh --destination /opt/ut99 --ui-mode none \
    --application-entry skip --desktop-shortcut skip

echo "==> Creating ut99 user..."
useradd --system --shell /usr/sbin/nologin --home-dir /opt/ut99 ut99 || true
chown -R ut99:ut99 /opt/ut99

echo "==> Downloading extra maps from DO Space..."
LISTING=$(curl -fsSL "$1")
MAPS=$(echo "$LISTING" | grep -oP '<Key>[^<>/]+\.[Uu][Nn][Rr]</Key>' | sed 's/<Key>//;s/<\/Key>//' || true)
for key in $MAPS; do
    echo "    Downloading $key..."
    curl -fsSL -o "/opt/ut99/Maps/$key" "$1/$key"
done
chown -R ut99:ut99 /opt/ut99/Maps

echo "==> Configuring server..."
INI="/opt/ut99/System64/UnrealTournament.ini"

sed -i 's/^CacheSizeMegs=.*/CacheSizeMegs=64/' "$INI"
sed -i 's/^NetServerMaxTickRate=.*/NetServerMaxTickRate=35/' "$INI"
sed -i 's/^MaxClientRate=.*/MaxClientRate=15000/' "$INI"
sed -i 's/^UseCompression=.*/UseCompression=True/' "$INI"
sed -i 's/^AllowDownloads=.*/AllowDownloads=True/' "$INI"
sed -i 's/^ServerName=.*/ServerName=UT99 Server/' "$INI"
sed -i 's/^MinPlayers=.*/MinPlayers=2/' "$INI"

echo "==> Configuring bot difficulty..."
sed -i 's/^Difficulty=.*/Difficulty=0/' /opt/ut99/System64/User.ini

echo "==> Installing systemd service..."
cat > /etc/systemd/system/ut99.service <<'SERVICE'
[Unit]
Description=Unreal Tournament 99 Dedicated Server
After=network.target

[Service]
Type=simple
User=ut99
Group=ut99
WorkingDirectory=/opt/ut99/System64
ExecStart=/opt/ut99/System64/ucc-bin server DM-Deck16][?game=Botpack.DeathMatchPlus -nohomedir
KillSignal=SIGINT
TimeoutStopSec=30
Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target
SERVICE

systemctl daemon-reload

echo "==> Configuring firewall..."
ufw --force reset
ufw default deny incoming
ufw default allow outgoing
ufw allow 22/tcp
ufw allow 7777:7779/udp
ufw --force enable

echo "==> Installing set-maps.sh helper..."
cat > /opt/ut99/set-maps.sh <<'SETMAPS'
#!/usr/bin/env bash
set -euo pipefail

[[ $# -ge 1 ]] || { echo "Usage: set-maps.sh MAP1 [MAP2 ...]" >&2; exit 1; }

MAPS_DIR="/opt/ut99/Maps"
INI="/opt/ut99/System64/UnrealTournament.ini"
SERVICE="/etc/systemd/system/ut99.service"

# Validate all maps exist (case-insensitive)
for map in "$@"; do
    found=false
    for f in "$MAPS_DIR"/*.unr; do
        basename=$(basename "$f" .unr)
        if [[ "${basename,,}" == "${map,,}" ]]; then
            found=true
            break
        fi
    done
    if [[ "$found" == "false" ]]; then
        echo "error: map '$map' not found in $MAPS_DIR" >&2
        exit 1
    fi
done

# Rewrite MapList entries in [Botpack.DeathMatchPlus] section
tmpfile=$(mktemp)
in_section=false
section_done=false

inject_maps() {
    local_index=0
    for map in "$@"; do
        echo "MapList[$local_index]=$map"
        ((local_index += 1))
    done
    echo "MapListCount=$#"
}

{
    while IFS= read -r line; do
        if [[ "$line" == "[Botpack.DeathMatchPlus]" ]]; then
            in_section=true
            echo "$line"
            continue
        fi

        if $in_section && ! $section_done; then
            # Skip existing MapList and MapListCount lines anywhere in the section
            if [[ "$line" =~ ^MapList\[ ]] || [[ "$line" =~ ^MapListCount= ]]; then
                continue
            fi

            # New section header means we're leaving — inject before it
            if [[ "$line" =~ ^\[.+\] ]]; then
                inject_maps "$@"
                section_done=true
                echo "$line"
                continue
            fi

            # Pass through all other lines in the section
            echo "$line"
            continue
        fi

        echo "$line"
    done

    # Handle case where section runs to EOF without another section header
    if $in_section && ! $section_done; then
        inject_maps "$@"
    fi
} < "$INI" > "$tmpfile"

mv "$tmpfile" "$INI"
chown ut99:ut99 "$INI"

# Update systemd ExecStart to use first map
sed -i "s|^\(ExecStart=/opt/ut99/System64/ucc-bin server \)[^ ?]*|\1$1|" "$SERVICE"

systemctl daemon-reload
systemctl restart ut99

echo "Map rotation set to: $*"
SETMAPS
chmod +x /opt/ut99/set-maps.sh

echo "==> Starting UT99 server..."
systemctl enable ut99
systemctl start ut99

echo "==> Provisioning complete"
PROVISION
}

cmd_create() {
    local droplet_id
    droplet_id=$(find_droplet)

    if [[ -n "$droplet_id" ]]; then
        local ip status
        ip=$(get_droplet_ip "$droplet_id")
        status=$(get_droplet_status "$droplet_id")
        if [[ "$status" == "active" ]]; then
            check_server_health "$ip"
        fi
        info "Droplet '$DROPLET_NAME' already exists at $ip (status: $status)"
        echo "$ip"
        return 0
    fi

    local ssh_keys
    ssh_keys=$(doctl compute ssh-key list --format FingerPrint --no-header | head -1)
    [[ -n "$ssh_keys" ]] || die "No SSH keys found in your DO account. Add one: doctl compute ssh-key create"

    info "Creating droplet '$DROPLET_NAME'..."
    droplet_id=$(doctl compute droplet create "$DROPLET_NAME" \
        --size "$DROPLET_SIZE" \
        --region "$REGION" \
        --image "$DROPLET_IMAGE" \
        --ssh-keys "$ssh_keys" \
        --format ID \
        --no-header \
        --wait)

    [[ -n "$droplet_id" ]] || die "Failed to create droplet"

    wait_for_active "$droplet_id"

    local ip
    ip=$(get_droplet_ip "$droplet_id")
    [[ -n "$ip" ]] || die "Droplet has no public IP"

    wait_for_ssh "$ip"
    provision_server "$ip"
    check_server_health "$ip"

    info "Setting map rotation..."
    cmd_maps "${MAP_ROTATION[@]}"

    info "UT99 server ready at ${ip}:7777"
    echo "$ip"
}

cmd_destroy() {
    local droplet_id
    droplet_id=$(find_droplet)

    if [[ -z "$droplet_id" ]]; then
        info "No droplet '$DROPLET_NAME' found — nothing to destroy"
        return 0
    fi

    info "Destroying droplet '$DROPLET_NAME' ($droplet_id)..."
    if ! doctl compute droplet delete "$droplet_id" --force 2>/dev/null; then
        # Check if it's already gone (DO API eventual consistency)
        if [[ -z "$(find_droplet)" ]]; then
            info "Droplet already gone"
            return 0
        fi
        die "Failed to destroy droplet $droplet_id"
    fi
    info "Destroyed"
}

cmd_start() {
    local droplet_id
    droplet_id=$(find_droplet)
    [[ -n "$droplet_id" ]] || die "No droplet '$DROPLET_NAME' found. Run: ut99 create"

    local status
    status=$(get_droplet_status "$droplet_id")

    if [[ "$status" == "active" ]]; then
        local ip
        ip=$(get_droplet_ip "$droplet_id")
        info "Droplet '$DROPLET_NAME' is already running at $ip"
        echo "$ip"
        return 0
    fi

    info "Powering on droplet '$DROPLET_NAME'..."
    doctl compute droplet-action power-on "$droplet_id" --wait > /dev/null

    wait_for_active "$droplet_id"

    local ip
    ip=$(get_droplet_ip "$droplet_id")
    check_server_health "$ip"

    info "UT99 server ready at ${ip}:7777"
    echo "$ip"
}

cmd_stop() {
    local droplet_id
    droplet_id=$(find_droplet)
    [[ -n "$droplet_id" ]] || die "No droplet '$DROPLET_NAME' found. Run: ut99 create"

    local status
    status=$(get_droplet_status "$droplet_id")

    if [[ "$status" == "off" ]]; then
        info "Droplet '$DROPLET_NAME' is already off"
        return 0
    fi

    info "Shutting down droplet '$DROPLET_NAME'..."
    doctl compute droplet-action shutdown "$droplet_id" --wait > /dev/null

    wait_for_off "$droplet_id"
    info "Droplet '$DROPLET_NAME' is off"
}

cmd_maps() {
    require_running_droplet

    if [[ $# -eq 0 ]]; then
        ssh root@"$DROPLET_IP" 'prefix=$(sed -n "s|.*ucc-bin server \([^-]*\)-.*|\1|p" /etc/systemd/system/ut99.service); for f in /opt/ut99/Maps/"${prefix}"-*.unr; do basename "$f" .unr; done' | sort
    else
        ssh root@"$DROPLET_IP" /opt/ut99/set-maps.sh "$@"
    fi
}

main() {
    [[ $# -ge 1 ]] || { usage; exit 1; }

    check_deps

    case "$1" in
        create)  cmd_create ;;
        destroy) cmd_destroy ;;
        start)   cmd_start ;;
        stop)    cmd_stop ;;
        maps)    cmd_maps "${@:2}" ;;
        *)       usage; exit 1 ;;
    esac
}

main "$@"
