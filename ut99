#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

die() {
    echo "error: $*" >&2
    exit 1
}

info() {
    echo "==> $*"
}

[[ -f "$SCRIPT_DIR/ut99.conf" ]] || die "Config file not found: $SCRIPT_DIR/ut99.conf (see ut99.conf.example)"
source "$SCRIPT_DIR/ut99.conf"
[[ -n "${DROPLET_NAME:-}" ]] || die "DROPLET_NAME not set in ut99.conf"
[[ -n "${REGION:-}" ]]       || die "REGION not set in ut99.conf"
# SPACE_NAME is optional — if set, extra maps are downloaded from DO Space during provisioning
[[ ${#MAP_ROTATION[@]} -gt 0 ]] 2>/dev/null || die "MAP_ROTATION not set in ut99.conf"

DROPLET_SIZE="s-1vcpu-1gb"
DROPLET_IMAGE="ubuntu-24-04-x64"

check_deps() {
    command -v doctl >/dev/null 2>&1 || die "doctl not found. Install from https://docs.digitalocean.com/reference/doctl/"
    command -v ssh >/dev/null 2>&1 || die "ssh not found"
    command -v nc >/dev/null 2>&1 || die "nc (netcat) not found"
    doctl account get >/dev/null 2>&1 || die "doctl not authenticated. Run: doctl auth init"
}

find_droplet() {
    doctl compute droplet list --format ID,Name --no-header \
        | awk -v name="$DROPLET_NAME" '$2 == name { print $1; exit }'
}

get_droplet_ip() {
    local droplet_id="$1"
    doctl compute droplet get "$droplet_id" --format PublicIPv4 --no-header
}

get_droplet_status() {
    local droplet_id="$1"
    doctl compute droplet get "$droplet_id" --format Status --no-header
}

require_running_droplet() {
    DROPLET_ID=$(find_droplet)
    [[ -n "$DROPLET_ID" ]] || die "No droplet '$DROPLET_NAME' found. Run: ut99 create"

    local status
    status=$(get_droplet_status "$DROPLET_ID")
    [[ "$status" == "active" ]] || die "Droplet '$DROPLET_NAME' is not running (status: $status)"

    DROPLET_IP=$(get_droplet_ip "$DROPLET_ID")
}

wait_for_active() {
    local droplet_id="$1"
    info "Waiting for droplet to become active..."
    local status
    for i in $(seq 1 60); do
        status=$(get_droplet_status "$droplet_id")
        [[ "$status" == "active" ]] && return 0
        sleep 5
    done
    die "Timed out waiting for droplet to become active (status: $status)"
}

wait_for_ssh() {
    local ip="$1"
    info "Waiting for SSH to become available..."
    for i in $(seq 1 60); do
        if ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=accept-new \
               "root@${ip}" true 2>/dev/null; then
            return 0
        fi
        sleep 5
    done
    die "Timed out waiting for SSH on $ip"
}

wait_for_off() {
    local droplet_id="$1"
    info "Waiting for droplet to power off..."
    local status
    for i in $(seq 1 60); do
        status=$(get_droplet_status "$droplet_id")
        [[ "$status" == "off" ]] && return 0
        sleep 5
    done
    die "Timed out waiting for droplet to power off (status: $status)"
}

check_server_health() {
    local ip="$1"
    info "Checking UT99 server is responding..."
    for i in $(seq 1 30); do
        if echo -ne '\\status\\' | nc -u -w 2 "$ip" 7778 2>/dev/null | grep -q '\\gamename\\ut\\'; then
            return 0
        fi
        sleep 2
    done
    die "UT99 server on $ip:7778 is not responding"
}

usage() {
    cat <<'USAGE'
Usage: ut99 <command>

Commands:
  create   Create and provision a UT99 server
  destroy  Destroy the UT99 server
  start    Start the UT99 server (power on)
  stop     Stop the UT99 server (power off)
  maps     List available maps, or set map rotation
USAGE
}

provision_server() {
    local ip="$1"
    local space_url=""
    [[ -n "${SPACE_NAME:-}" ]] && space_url="https://${SPACE_NAME}.${REGION}.digitaloceanspaces.com"

    info "Provisioning UT99 server on $ip..."

    scp -o StrictHostKeyChecking=accept-new -r "$SCRIPT_DIR/server" "root@${ip}:/tmp/ut99-server"
    ssh -o StrictHostKeyChecking=accept-new "root@${ip}" /tmp/ut99-server/provision.sh "$space_url"
}

cmd_create() {
    local droplet_id
    droplet_id=$(find_droplet)

    if [[ -n "$droplet_id" ]]; then
        local ip status
        ip=$(get_droplet_ip "$droplet_id")
        status=$(get_droplet_status "$droplet_id")
        if [[ "$status" == "active" ]]; then
            check_server_health "$ip"
        fi
        info "Droplet '$DROPLET_NAME' already exists at $ip (status: $status)"
        echo "$ip"
        return 0
    fi

    local ssh_keys
    ssh_keys=$(doctl compute ssh-key list --format FingerPrint --no-header | head -1)
    [[ -n "$ssh_keys" ]] || die "No SSH keys found in your DO account. Add one: doctl compute ssh-key create"

    info "Creating droplet '$DROPLET_NAME'..."
    droplet_id=$(doctl compute droplet create "$DROPLET_NAME" \
        --size "$DROPLET_SIZE" \
        --region "$REGION" \
        --image "$DROPLET_IMAGE" \
        --ssh-keys "$ssh_keys" \
        --format ID \
        --no-header \
        --wait)

    [[ -n "$droplet_id" ]] || die "Failed to create droplet"

    wait_for_active "$droplet_id"

    local ip
    ip=$(get_droplet_ip "$droplet_id")
    [[ -n "$ip" ]] || die "Droplet has no public IP"

    wait_for_ssh "$ip"
    provision_server "$ip"
    check_server_health "$ip"

    info "Setting map rotation..."
    cmd_maps "${MAP_ROTATION[@]}"

    info "UT99 server ready at ${ip}:7777"
    echo "$ip"
}

cmd_destroy() {
    local droplet_id
    droplet_id=$(find_droplet)

    if [[ -z "$droplet_id" ]]; then
        info "No droplet '$DROPLET_NAME' found — nothing to destroy"
        return 0
    fi

    info "Destroying droplet '$DROPLET_NAME' ($droplet_id)..."
    if ! doctl compute droplet delete "$droplet_id" --force 2>/dev/null; then
        # Check if it's already gone (DO API eventual consistency)
        if [[ -z "$(find_droplet)" ]]; then
            info "Droplet already gone"
            return 0
        fi
        die "Failed to destroy droplet $droplet_id"
    fi

    info "Waiting for droplet to be removed..."
    for i in $(seq 1 60); do
        [[ -z "$(find_droplet)" ]] && break
        sleep 5
    done
    [[ -z "$(find_droplet)" ]] || die "Timed out waiting for droplet to be removed"

    info "Destroyed"
}

cmd_start() {
    local droplet_id
    droplet_id=$(find_droplet)
    [[ -n "$droplet_id" ]] || die "No droplet '$DROPLET_NAME' found. Run: ut99 create"

    local status
    status=$(get_droplet_status "$droplet_id")

    if [[ "$status" == "active" ]]; then
        local ip
        ip=$(get_droplet_ip "$droplet_id")
        info "Droplet '$DROPLET_NAME' is already running at $ip"
        echo "$ip"
        return 0
    fi

    info "Powering on droplet '$DROPLET_NAME'..."
    doctl compute droplet-action power-on "$droplet_id" --wait > /dev/null

    wait_for_active "$droplet_id"

    local ip
    ip=$(get_droplet_ip "$droplet_id")
    check_server_health "$ip"

    info "UT99 server ready at ${ip}:7777"
    echo "$ip"
}

cmd_stop() {
    local droplet_id
    droplet_id=$(find_droplet)
    [[ -n "$droplet_id" ]] || die "No droplet '$DROPLET_NAME' found. Run: ut99 create"

    local status
    status=$(get_droplet_status "$droplet_id")

    if [[ "$status" == "off" ]]; then
        info "Droplet '$DROPLET_NAME' is already off"
        return 0
    fi

    info "Shutting down droplet '$DROPLET_NAME'..."
    doctl compute droplet-action shutdown "$droplet_id" --wait > /dev/null

    wait_for_off "$droplet_id"
    info "Droplet '$DROPLET_NAME' is off"
}

cmd_maps() {
    require_running_droplet

    if [[ $# -eq 0 ]]; then
        ssh root@"$DROPLET_IP" 'prefix=$(sed -n "s|.*ucc-bin server \([^-]*\)-.*|\1|p" /etc/systemd/system/ut99.service); for f in /opt/ut99/Maps/"${prefix}"-*.unr; do basename "$f" .unr; done' | sort
    else
        ssh root@"$DROPLET_IP" /opt/ut99/set-maps.sh "$@"
    fi
}

main() {
    [[ $# -ge 1 ]] || { usage; exit 1; }

    check_deps

    case "$1" in
        create)  cmd_create ;;
        destroy) cmd_destroy ;;
        start)   cmd_start ;;
        stop)    cmd_stop ;;
        maps)    cmd_maps "${@:2}" ;;
        *)       usage; exit 1 ;;
    esac
}

main "$@"
